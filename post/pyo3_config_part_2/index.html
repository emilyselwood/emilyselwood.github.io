<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Using python to configure rust Part 2 | Parsecs Reach</title>
<meta name="keywords" content="rust, python, pyo3">
<meta name="description" content="Continuing on from Part 1 If you&rsquo;ve not read that you probably should before continuing here. Previously we setup a pyo3 project and ran some python code from rust which was able to create a rust class and return it to rust. (I think I can say rust a few more times in this paragraph. Rust rust rust)
This is the kind of python config we are aiming to be able to use inside our rust program:">
<meta name="author" content="Emily Selwood">
<link rel="canonical" href="https://parsecsreach.org/post/pyo3_config_part_2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.979d31a757b649bf90615e658aedd46e2896dc33bf05775ea99697ce5b3e4fe4.css" integrity="sha256-l50xp1e2Sb&#43;QYV5liu3UbiiW3DO/BXdeqZaXzls&#43;T&#43;Q=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://parsecsreach.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://parsecsreach.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://parsecsreach.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://parsecsreach.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://parsecsreach.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Using python to configure rust Part 2" />
<meta property="og:description"
  content="Continuing on from Part 1 If you&rsquo;ve not read that you probably should before continuing here. Previously we setup a pyo3 project and ran some python code from rust which was able to create a rust class and return it to rust. (I think I can say rust a few more times in this paragraph. Rust rust rust)
This is the kind of python config we are aiming to be able to use inside our rust program:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://parsecsreach.org/post/pyo3_config_part_2/" />
<meta name="fediverse:creator" content="@emily_s@mastodon.me.uk"><meta property="article:section" content="post" />

<meta property="article:published_time" content="2025-11-26T18:02:00+00:00" />

<meta property="article:modified_time" content="2025-11-26T18:02:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Using python to configure rust Part 2"/>
<meta name="twitter:description" content="Continuing on from Part 1 If you&rsquo;ve not read that you probably should before continuing here. Previously we setup a pyo3 project and ran some python code from rust which was able to create a rust class and return it to rust. (I think I can say rust a few more times in this paragraph. Rust rust rust)
This is the kind of python config we are aiming to be able to use inside our rust program:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://parsecsreach.org/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Using python to configure rust Part 2",
      "item": "https://parsecsreach.org/post/pyo3_config_part_2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Using python to configure rust Part 2",
  "name": "Using python to configure rust Part 2",
  "description": "Continuing on from Part 1 If you\u0026rsquo;ve not read that you probably should before continuing here. Previously we setup a pyo3 project and ran some python code from rust which was able to create a rust class and return it to rust. (I think I can say rust a few more times in this paragraph. Rust rust rust)\nThis is the kind of python config we are aiming to be able to use inside our rust program:",
  "keywords": [
    "rust", "python", "pyo3"
  ],
  "articleBody": "Continuing on from Part 1 If you’ve not read that you probably should before continuing here. Previously we setup a pyo3 project and ran some python code from rust which was able to create a rust class and return it to rust. (I think I can say rust a few more times in this paragraph. Rust rust rust)\nThis is the kind of python config we are aiming to be able to use inside our rust program:\n@configure def configA(): return Config( name= \"blah\" ) @configure def configB(configA): return Config( name= configA.name + \"_with_something_extra\" ) @configure def configC(configA, configB): return Config( name= configB.name + \"_and_even_more_\" + configA.name, ) Note the use of the @configure decorator to mark functions that do configuration stuff. That is the first thing we are going to do today.\nStep 3: Find all the functions with the decorator Slight side bar: what the heck is a decorator?\nIn python a decorator is a bit of syntactic sugar for wrapping a function in another one. Defined by a function that takes the function its “attached” to as a parameter and returns a function. We could implement this configure decorator in python like so:\nLIST_OF_FUNCTIONS=[] def configure(inner_func): LIST_OF_FUNCTIONS.append(inner_func) return inner_func We could then loop over LIST_OF_FUNCTIONS and we’d have all our functions.\nOf course we need that list in rust. Which isn’t the easiest thing to create, what we just made in python is a global mutable variable. Which is a terrible idea as soon as more than one thread is involved. So rust doesn’t let you do that.\nLet me introduce you to the append only vec\nOnce that’s added to our Cargo.toml we can add this to our rust python module.\nuse append_only_vec::AppendOnlyVec; pub static CONFIGURE_FUNCTIONS: AppendOnlyVec\u003cPy\u003cPyAny\u003e\u003e = AppendOnlyVec::new(); #[pyfunction] pub fn configure(py: Python, inner: Py\u003cPyAny\u003e) -\u003e PyResult\u003cPy\u003cPyAny\u003e\u003e { CONFIGURE_FUNCTIONS.push(inner.clone_ref(py)); Ok(inner) } Please don’t ask me how that works but the AppendOnlyVec is doing some magic that lets it add to its self with out being a modifiable version of its self. In the python code we can import the configure function along with the Config object and we can wrap our configure functions in the decorator as in the first code block.\nfrom pyconfigmod import Config, configure @configure def configA(): return Config( name= \"blah\" ) @configure def configB(configA): return Config( name= configA.name + \"_with_something_extra\" ) @configure def configC(configA, configB): return Config( name= configB.name + \"_and_even_more_\" + configA.name, ) Now we have a list of functions we can loop over them. However we don’t know what their parameters are or what order we need to execute them in. So …\nStep 4: Finding the arguments for the functions. At the moment we have a list of function references. We don’t know what they are called and we don’t know what arguments they take.\nPython objects have a bunch of built in attributes commonly called magic methods, special methods, or dunder methods. They are the ones that have two underscores around their names. There is a helpful list of them in the python documentation.\nThe one we need here is one I’ve not used in python before. __code__ This contains information about the code that created the object. Details can be found, as usual, in the python docs. For our needs we can use the co_name attribute to get the function name. I’m not using the co_qualname because I’ve not decided on a good mapping for characters that aren’t allowed in parameter names. This does mean we need all @configure functions to have unique names, which kind of sucks currently. This can be a project for later.\nThe arguments to the function are a little more complex. Rather than separating out the arguments, they are part of the list of local variables. There is co_argcount which will give us how many there are, so we can pull them from the front of the list of local variables.\nFirst lets get the function name\nfn get_func_name\u003c'l\u003e(_py: Python\u003c'l\u003e, func: \u0026Bound\u003c'l, PyAny\u003e) -\u003e PyResult\u003cString\u003e { if !func.is_callable() { // TODO: figure out error handling panic!(\"Object not callable.\") } let code = func.getattr(\"__code__\")?; let name: String = code.getattr(\"co_name\")?.extract()?; Ok(name) } I really need to sort out error handling at some point, but I’m still in prototype mode so I’m just going to panic if we get given something that isn’t a function.\nIn the function we get the __code__ attribute and then the co_name attribute from that, then we are done.\nNow we can move on to the arguments.\nfn get_arg_names\u003c'l\u003e(_py: Python\u003c'l\u003e, func: \u0026Bound\u003c'l, PyAny\u003e) -\u003e PyResult\u003cVec\u003cString\u003e\u003e { if !func.is_callable() { // TODO: figure out error handling panic!(\"Object not callable.\") } let code = func.getattr(\"__code__\")?; let arg_count: i32 = code.getattr(\"co_argcount\")?.extract()?; let bound_var_names: Bound\u003c'l, PyAny\u003e = code.getattr(\"co_varnames\")?; if bound_var_names.is_instance_of::\u003cPyTuple\u003e() { let tuple = bound_var_names.cast::\u003cPyTuple\u003e()?; let mut result = Vec::new(); for i in 0..arg_count as usize { let arg_name: String = tuple.get_item(i)?.extract()?; result.push(arg_name); } Ok(result) } else { panic!(\"co_varnames wasn't a tuple\") } } This is a bit more complex … We grab the __code__ attribute. We grab the co_argcount from it so we know how many arguments will be on the front of the co_varnames tuple. We then have to do some slightly nasty casting to get our PyAny into a PyTuple which we can then loop over the arg_count entries and pull out the argument names.\nI feel ok panicking if the co_varnames attribute isn’t a tuple given that its a built in python type and if that goes wrong the entire python environment is likely in flames so we won’t be able to do much any way. Should probably check that the tuple actually has arg_count entries too but again, if the python environment we are using has gone that far wrong we have bigger issues.\nNow that we have a way to get the name and arguments of a python function in rust land, we can build a HashMap of function name to arguments. In our main, after we have attached all the modules, we can do something like the following.\nlet mut dependencies: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::new(); let mut functions: HashMap\u003cString, Bound\u003cPyAny\u003e\u003e = HashMap::new(); for func in pyconfigmod::CONFIGURE_FUNCTIONS.iter() { let bind = func.bind(py); if bind.is_callable() { let func_name = get_func_name(py, bind)?; let mut arg_names = get_arg_names(py, bind)?; println!(\"func {} args: {:?}\", func_name, arg_names); functions.insert(func_name.clone(), bind.clone()); dependencies .entry(func_name) .or_insert_with(Vec::new) .append(\u0026mut arg_names); } } Here we are going through the CONFIGURE_FUNCTIONS list we created with the decorator, which got run when we loaded the module. Binding the functions to our python instance, so we can pass around references nicely. Then if its callable grabbing its name and arguments and adding them to the dependencies map. I’m also creating a name to function look up at the same time, we will need that later.\nPart 5: Sorting our functions Now that we have our functions and know the names of their arguments we can sort them to work out the order that they need to run so we have the arguments required for each function before we call it. This set of functions is called a Directed Acyclic Graph (or DAG for short) This is a bunch of fancy words to mean they form a tree structure, with out any loops (or cycles).\nThe really important thing for us is the lack of cycles. If we have functions that depend on each other then we will not be able to run them because there is no way for us to start. E.G\n@configure def configA(configB): return Config(name=\"Config A\" + configA.name) @configure def configB(configA): return Config(name=\"Config B\" + configA.name) To work out configB we need configA and to work out configA we need configB which is impossible for us to do. So we will be raising an error if this happens.\nThere are quite a few guides on doing a DAG sort online. I’m going to include the code I wrote here and explain it, as its not too long.\nfn remove_args(funcs: \u0026mut HashMap\u003cString, Vec\u003cString\u003e\u003e, name: \u0026str) { for (_k, v) in funcs.iter_mut() { if let Some(pos) = v.iter().position(|e| e == name) { v.remove(pos); } } } fn sort_functions(funcs: \u0026HashMap\u003cString, Vec\u003cString\u003e\u003e) -\u003e Vec\u003cString\u003e { let mut working = funcs.clone(); let mut result = Vec::new(); while !working.is_empty() { let keys: Vec\u003cString\u003e = working.keys().cloned().collect(); let mut found_something = false; for k in keys { let args = working.get(\u0026k).unwrap(); if args.is_empty() { result.push(k.clone()); remove_args(\u0026mut working, \u0026k); working.remove(\u0026k); found_something = true; break; } } // if we get here without breaking then we must have a loop or arguments that don't match functions. if !found_something { // TODO: real errors here please println!(\"working left with: {:?}\", working); panic!( \"Could not find any functions that have no parameters left. There must be a loop or parameters that don't match any functions.\" ) } } return result; } First we need a modifiable copy of our hashmap of functions and their arguments, we need to remove things from this as we work so its nicer to take a clone of it here.\nThen we get on to the actual algorithm its self. This looks a bit more complex due to rust and the borrow checker, but the principle remains the same. Look through our working map of functions, find one that doesn’t have any arguments. This means it has no dependencies, so add it to the result list. Then go through the working map and remove any arguments with the name of the function we have. We also need to remove the function from the working map or we will end up with an infinite loop.\nThen we start again, and we keep going until the working map is empty. If we ever manage to loop over all the entries in the working map and don’t find an entry that has no arguments, it means we have a loop somewhere, or we have argument names that don’t match a function we know of. Either way that’s an error and we need to tell the user about it, or in our case panic and stop the program.\nOne thing to note about this implementation is it is not entirely stable, by design. If there are two functions that take the same arguments, we don’t care what order they run in. working.keys() returns the keys in a random order. If two configs don’t have a defined order it should not matter which order they run in. If there is accidentally a dependency then that is a bug and they should have an extra parameter to make the ordering defined.\nPart 6: Running the configure functions Now that we have the information about all the configure functions and know the order they need to be executed in, we can start running them.\nlet sorted_functions = sort_functions(\u0026dependencies); println!(\"{:?}\", sorted_functions); // execute the functions, keeping track of their results, looking up the arguments as needed. let mut results_map: HashMap\u003cString, Config\u003e = HashMap::new(); for func_name in sorted_functions { println!(\"Executing {}\", \u0026func_name); let args = dependencies.get(\u0026func_name).unwrap(); let kwargs = create_kwargs(py, \u0026results_map, args)?; let result: Config = functions .get(\u0026func_name) .unwrap() .call((), Some(\u0026kwargs))? .extract()?; results_map.insert(func_name.clone(), result); } println!(\"results: {:?}\", results_map); The code here loops over the list of function names that comes out of the sort function. Builds a set of kwargs (Key word args in python land) which is a PyDict that gets expanded into named arguments. Calls the function with those kwargs and finally stores the result for later.\nWhen we create the kwargs we have to build a PyDict, I also convert our Config objects into ReadOnlyConfig objects so that later configure functions can not mess with the results of earlier functions. This is a near clone of the original Config object but it doesn’t have the constructor function or the set_all argument on the pyclass macro. There is also a function to create one from a Config object.\nThe create_kwargs is as follows:\nfn create_kwargs\u003c'l\u003e( py: Python\u003c'l\u003e, existing_results: \u0026HashMap\u003cString, Config\u003e, args: \u0026Vec\u003cString\u003e, ) -\u003e PyResult\u003cBound\u003c'l, PyDict\u003e\u003e { let result = PyDict::new(py); for arg in args { let cr = existing_results.get(\u0026arg.to_string()); if cr.is_none() { panic!( \"Couldn't find existing result for {}. This shouldn't be possible if the sort worked right\", arg ); } result.set_item(arg, ReadOnlyConfig::from_config(cr.unwrap()))?; } Ok(result) } As usual the error handling can be massively improved here, but something has gone horribly wrong if we don’t have a result for a function we need. The sort would have had to have broken somehow.\nNow we have a fully working configuration system, if MVP level of implementation, rather than production code. Lets run it on our config and see what happens.\nemily@diamondslab:~/Projects/breezeblock$ cargo run Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s Running `target/debug/breezeblock` func configA args: [] func configB args: [\"configA\"] func configC args: [\"configA\", \"configB\"] dependencies: {\"configC\": [\"configA\", \"configB\"], \"configA\": [], \"configB\": [\"configA\"]} [\"configA\", \"configB\", \"configC\"] Executing configA Executing configB Executing configC results: {\"configB\": Config { config_class: \"\", repository: \"\", name: \"blah_with_something_extra\", features: [], parameters: {} }, \"configC\": Config { config_class: \"\", repository: \"\", name: \"blah_with_something_extra_and_even_more_blah\", features: [], parameters: {} }, \"configA\": Config { config_class: \"\", repository: \"\", name: \"blah\", features: [], parameters: {} }} In the results section at the end we can see it has done what we wanted.\nThere are many improvements that could be made here, but the basic principle works just fine. Now we can go and do something with our config objects.\nI’ve pushed the full code up to codeberg so if you want to play around with it feel free. If you find this interesting or want to use it in something I’d love to hear from you, drop me a message on mastodon @emily_s@mastodon.me.uk\n",
  "wordCount" : "2261",
  "inLanguage": "en",
  "datePublished": "2025-11-26T18:02:00Z",
  "dateModified": "2025-11-26T18:02:00Z",
  "author":{
    "@type": "Person",
    "name": "Emily Selwood"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://parsecsreach.org/post/pyo3_config_part_2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Parsecs Reach",
    "logo": {
      "@type": "ImageObject",
      "url": "https://parsecsreach.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://parsecsreach.org" accesskey="h" title="Parsecs Reach (Alt + H)">Parsecs Reach</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a rel="me" href="https://mastodon.me.uk/@emily_s"  target="_blank" title="">
                    <span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 417.8 512" class="logo-social" width="18" height="18"><path d="M417.8 179.1c0-97.2-63.7-125.7-63.7-125.7-62.5-28.7-228.5-28.4-290.4 0 0 0-63.7 28.5-63.7 125.7 0 115.7-6.6 259.4 105.6 289.1 40.5 10.7 75.3 13 103.3 11.4 50.8-2.8 79.3-18.1 79.3-18.1l-1.7-36.9s-36.3 11.4-77.1 10.1c-40.4-1.4-83-4.4-89.6-54-.6-4.4-.9-9-.9-13.9 85.6 20.9 158.6 9.1 178.7 6.7 56.1-6.7 105-41.3 111.2-72.9 9.8-49.8 9-121.5 9-121.5zm-75.1 125.2h-46.6V190.1c0-49.7-64-51.6-64 6.9v62.5h-46.3V197c0-58.5-64-56.6-64-6.9v114.2H75.1c0-122.1-5.2-147.9 18.4-175 25.9-28.9 79.8-30.8 103.8 6.1l11.6 19.5 11.6-19.5c24.1-37.1 78.1-34.8 103.8-6.1 23.7 27.3 18.4 53 18.4 175z"/></svg></span>
                    
                </a>
            </li>
            <li>
                <a rel="" href="https://github.com/emilyselwood"  target="_blank" title="">
                    <span><svg width="18" height="18" class="logo-social" stroke="none" viewBox="0 0 11.493062 11.209467" xmlns="http://www.w3.org/2000/svg"><path d="M 5.746044,0 C 2.572808,0 0,2.572808 0,5.74675 c 0,2.538941 1.646414,4.69265 3.929944,5.452886 0.287514,0.05256 0.392289,-0.124883 0.392289,-0.277283 0,-0.136173 -0.0049,-0.49777 -0.0078,-0.977195 C 2.715997,10.292291 2.378741,9.174691 2.378741,9.174691 2.117333,8.511116 1.740566,8.334375 1.740566,8.334375 1.218808,7.977716 1.780076,7.984772 1.780076,7.984772 2.356868,8.025692 2.660257,8.577086 2.660257,8.577086 3.172843,9.45515 4.005398,9.201503 4.332776,9.054747 4.384986,8.683272 4.533154,8.429978 4.697548,8.286397 3.421551,8.141405 2.079937,7.648222 2.079937,5.446183 c 0,-0.627239 0.224014,-1.140178 0.591609,-1.541991 -0.05927,-0.145345 -0.25647,-0.729545 0.05609,-1.520825 0,0 0.4826,-0.154517 1.580445,0.589138 C 4.766339,2.845153 5.258111,2.7813 5.746709,2.779183 6.2346,2.781283 6.726372,2.845153 7.185336,2.972505 8.282475,2.22885 8.764017,2.383367 8.764017,2.383367 c 0.313619,0.79128 0.116416,1.37548 0.05715,1.520825 0.3683,0.401813 0.590903,0.914752 0.590903,1.541991 0,2.207683 -1.343731,2.693458 -2.623961,2.835628 0.206375,0.177447 0.390172,0.528108 0.390172,1.06433 0,0.767998 -0.0071,1.387828 -0.0071,1.576212 0,0.153811 0.103364,0.332669 0.395111,0.276577 2.281767,-0.761647 3.92677,-2.913944 3.92677,-5.45218 C 11.493062,2.572808 8.919901,0 5.745959,0"/></svg></span>
                    
                </a>
            </li>
            <li>
                <a rel="" href="https://parsecsreach.org/projects"  target="_self" title="Projects">
                    <span>Projects</span>
                    
                </a>
            </li>
            <li>
                <a rel="" href="https://parsecsreach.org/"  target="_self" title="Home">
                    <span>Home</span>
                    
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Using python to configure rust Part 2
    </h1>
    <div class="post-meta"><span title='2025-11-26 18:02:00 +0000 GMT'>2025 November 26</span>&nbsp;·&nbsp;Emily Selwood

</div>
  </header> 
  <div class="post-content"><p>Continuing on from <a href="/post/pyo3_config_part_1">Part 1</a> If you&rsquo;ve not read that you probably should before continuing here. Previously we setup a pyo3 project and ran some python code from rust which was able to create a rust class and return it to rust. (I think I can say rust a few more times in this paragraph. Rust rust rust)</p>
<p>This is the kind of python config we are aiming to be able to use inside our rust program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configA</span>():
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Config(
</span></span><span style="display:flex;"><span>    name<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;blah&#34;</span>
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configB</span>(configA):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Config(
</span></span><span style="display:flex;"><span>    name<span style="color:#f92672">=</span> configA<span style="color:#f92672">.</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_with_something_extra&#34;</span>
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configC</span>(configA, configB):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Config(
</span></span><span style="display:flex;"><span>    name<span style="color:#f92672">=</span> configB<span style="color:#f92672">.</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_and_even_more_&#34;</span> <span style="color:#f92672">+</span> configA<span style="color:#f92672">.</span>name,
</span></span><span style="display:flex;"><span>  )
</span></span></code></pre></div><p>Note the use of the <code>@configure</code> decorator to mark functions that do configuration stuff. That is the first thing we are going to do today.</p>
<h2 id="step-3-find-all-the-functions-with-the-decorator">Step 3: Find all the functions with the decorator<a hidden class="anchor" aria-hidden="true" href="#step-3-find-all-the-functions-with-the-decorator">#</a></h2>
<p>Slight side bar: what the heck is a decorator?</p>
<p>In python a decorator is a bit of syntactic sugar for wrapping a function in another one. Defined by a function that takes the function its &ldquo;attached&rdquo; to as a parameter and returns a function. We could implement this <code>configure</code> decorator in python like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>LIST_OF_FUNCTIONS<span style="color:#f92672">=</span>[]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configure</span>(inner_func):
</span></span><span style="display:flex;"><span>    LIST_OF_FUNCTIONS<span style="color:#f92672">.</span>append(inner_func)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> inner_func
</span></span></code></pre></div><p>We could then loop over <code>LIST_OF_FUNCTIONS</code> and we&rsquo;d have all our functions.</p>
<p>Of course we need that list in rust. Which isn&rsquo;t the easiest thing to create, what we just made in python is a global mutable variable. Which is a terrible idea as soon as more than one thread is involved. So rust doesn&rsquo;t let you do that.</p>
<p>Let me introduce you to the <a href="https://crates.io/crates/append-only-vec">append only vec</a></p>
<p>Once that&rsquo;s added to our <code>Cargo.toml</code> we can add this to our rust python module.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> append_only_vec::AppendOnlyVec;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">CONFIGURE_FUNCTIONS</span>: <span style="color:#a6e22e">AppendOnlyVec</span><span style="color:#f92672">&lt;</span>Py<span style="color:#f92672">&lt;</span>PyAny<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> AppendOnlyVec::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[pyfunction]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">configure</span>(py: <span style="color:#a6e22e">Python</span>, inner: <span style="color:#a6e22e">Py</span><span style="color:#f92672">&lt;</span>PyAny<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">PyResult</span><span style="color:#f92672">&lt;</span>Py<span style="color:#f92672">&lt;</span>PyAny<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">CONFIGURE_FUNCTIONS</span>.push(inner.clone_ref(py));
</span></span><span style="display:flex;"><span>    Ok(inner)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Please don&rsquo;t ask me how that works but the <code>AppendOnlyVec</code> is doing some magic that lets it add to its self with out being a modifiable version of its self. In the python code we can import the configure function along with the Config object and we can wrap our configure functions in the decorator as in the first code block.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pyconfigmod <span style="color:#f92672">import</span> Config, configure
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configA</span>():
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Config(
</span></span><span style="display:flex;"><span>    name<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;blah&#34;</span>
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configB</span>(configA):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Config(
</span></span><span style="display:flex;"><span>    name<span style="color:#f92672">=</span> configA<span style="color:#f92672">.</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_with_something_extra&#34;</span>
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configC</span>(configA, configB):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Config(
</span></span><span style="display:flex;"><span>    name<span style="color:#f92672">=</span> configB<span style="color:#f92672">.</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_and_even_more_&#34;</span> <span style="color:#f92672">+</span> configA<span style="color:#f92672">.</span>name,
</span></span><span style="display:flex;"><span>  )
</span></span></code></pre></div><p>Now we have a list of functions we can loop over them. However we don&rsquo;t know what their parameters are or what order we need to execute them in. So &hellip;</p>
<h2 id="step-4-finding-the-arguments-for-the-functions">Step 4: Finding the arguments for the functions.<a hidden class="anchor" aria-hidden="true" href="#step-4-finding-the-arguments-for-the-functions">#</a></h2>
<p>At the moment we have a list of function references. We don&rsquo;t know what they are called and we don&rsquo;t know what arguments they take.</p>
<p>Python objects have a bunch of built in attributes commonly called magic methods, special methods, or dunder methods. They are the ones that have two underscores around their names. There is a helpful list of them in the <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">python documentation</a>.</p>
<p>The one we need here is one I&rsquo;ve not used in python before. <code>__code__</code> This contains information about the code that created the object. Details can be found, as usual, in the <a href="https://docs.python.org/3/reference/datamodel.html#code-objects">python docs</a>. For our needs we can use the <code>co_name</code> attribute to get the function name. I&rsquo;m not using the <code>co_qualname</code> because I&rsquo;ve not decided on a good mapping for characters that aren&rsquo;t allowed in parameter names. This does mean we need all <code>@configure</code> functions to have unique names, which kind of sucks currently. This can be a project for later.</p>
<p>The arguments to the function are a little more complex. Rather than separating out the arguments, they are part of the list of local variables. There is <code>co_argcount</code> which will give us how many there are, so we can pull them from the front of the list of local variables.</p>
<p>First lets get the function name</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_func_name</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span><span style="color:#f92672">&gt;</span>(_py: <span style="color:#a6e22e">Python</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span><span style="color:#f92672">&gt;</span>, func: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Bound</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span>, PyAny<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">PyResult</span><span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>func.is_callable() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO: figure out error handling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        panic!(<span style="color:#e6db74">&#34;Object not callable.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> code <span style="color:#f92672">=</span> func.getattr(<span style="color:#e6db74">&#34;__code__&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String <span style="color:#f92672">=</span> code.getattr(<span style="color:#e6db74">&#34;co_name&#34;</span>)<span style="color:#f92672">?</span>.extract()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    Ok(name)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I really need to sort out error handling at some point, but I&rsquo;m still in prototype mode so I&rsquo;m just going to panic if we get given something that isn&rsquo;t a function.</p>
<p>In the function we get the <code>__code__</code> attribute and then the <code>co_name</code> attribute from that, then we are done.</p>
<p>Now we can move on to the arguments.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_arg_names</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span><span style="color:#f92672">&gt;</span>(_py: <span style="color:#a6e22e">Python</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span><span style="color:#f92672">&gt;</span>, func: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Bound</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span>, PyAny<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">PyResult</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>func.is_callable() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO: figure out error handling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        panic!(<span style="color:#e6db74">&#34;Object not callable.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> code <span style="color:#f92672">=</span> func.getattr(<span style="color:#e6db74">&#34;__code__&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> arg_count: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> code.getattr(<span style="color:#e6db74">&#34;co_argcount&#34;</span>)<span style="color:#f92672">?</span>.extract()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bound_var_names: <span style="color:#a6e22e">Bound</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span>, PyAny<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> code.getattr(<span style="color:#e6db74">&#34;co_varnames&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> bound_var_names.is_instance_of::<span style="color:#f92672">&lt;</span>PyTuple<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> tuple <span style="color:#f92672">=</span> bound_var_names.cast::<span style="color:#f92672">&lt;</span>PyTuple<span style="color:#f92672">&gt;</span>()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>arg_count <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> arg_name: String <span style="color:#f92672">=</span> tuple.get_item(i)<span style="color:#f92672">?</span>.extract()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            result.push(arg_name);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Ok(result)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        panic!(<span style="color:#e6db74">&#34;co_varnames wasn&#39;t a tuple&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a bit more complex &hellip; We grab the <code>__code__</code> attribute. We grab the <code>co_argcount</code> from it so we know how many arguments will be on the front of the <code>co_varnames</code> tuple. We then have to do some slightly nasty casting to get our <code>PyAny</code> into a <code>PyTuple</code> which we can then loop over the <code>arg_count</code> entries and pull out the argument names.</p>
<p>I feel ok panicking if the <code>co_varnames</code> attribute isn&rsquo;t a tuple given that its a built in python type and if that goes wrong the entire python environment is likely in flames so we won&rsquo;t be able to do much any way. Should probably check that the tuple actually has <code>arg_count</code> entries too but again, if the python environment we are using has gone that far wrong we have bigger issues.</p>
<p>Now that we have a way to get the name and arguments of a python function in rust land, we can build a <code>HashMap</code> of function name to arguments. In our main, after we have attached all the modules, we can do something like the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> dependencies: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> functions: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, Bound<span style="color:#f92672">&lt;</span>PyAny<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> func <span style="color:#66d9ef">in</span> pyconfigmod::<span style="color:#66d9ef">CONFIGURE_FUNCTIONS</span>.iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> bind <span style="color:#f92672">=</span> func.bind(py);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> bind.is_callable() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> func_name <span style="color:#f92672">=</span> get_func_name(py, bind)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> arg_names <span style="color:#f92672">=</span> get_arg_names(py, bind)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                println!(<span style="color:#e6db74">&#34;func </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> args: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, func_name, arg_names);
</span></span><span style="display:flex;"><span>                functions.insert(func_name.clone(), bind.clone());
</span></span><span style="display:flex;"><span>                dependencies
</span></span><span style="display:flex;"><span>                    .entry(func_name)
</span></span><span style="display:flex;"><span>                    .or_insert_with(Vec::new)
</span></span><span style="display:flex;"><span>                    .append(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> arg_names);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>Here we are going through the <code>CONFIGURE_FUNCTIONS</code> list we created with the decorator, which got run when we loaded the module. Binding the functions to our python instance, so we can pass around references nicely. Then if its callable grabbing its name and arguments and adding them to the dependencies map. I&rsquo;m also creating a name to function look up at the same time, we will need that later.</p>
<h1 id="part-5-sorting-our-functions">Part 5: Sorting our functions<a hidden class="anchor" aria-hidden="true" href="#part-5-sorting-our-functions">#</a></h1>
<p>Now that we have our functions and know the names of their arguments we can sort them to work out the order that they need to run so we have the arguments required for each function before we call it. This set of functions is called a Directed Acyclic Graph (or DAG for short) This is a bunch of fancy words to mean they form a tree structure, with out any loops (or cycles).</p>
<p>The really important thing for us is the lack of cycles. If we have functions that depend on each other then we will not be able to run them because there is no way for us to start. E.G</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configA</span>(configB):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Config(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Config A&#34;</span> <span style="color:#f92672">+</span> configA<span style="color:#f92672">.</span>name)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@configure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">configB</span>(configA):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Config(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Config B&#34;</span> <span style="color:#f92672">+</span> configA<span style="color:#f92672">.</span>name)
</span></span></code></pre></div><p>To work out <code>configB</code> we need <code>configA</code> and to work out <code>configA</code> we need <code>configB</code> which is impossible for us to do. So we will be raising an error if this happens.</p>
<p>There are quite a few guides on doing a DAG sort online. I&rsquo;m going to include the code I wrote here and explain it, as its not too long.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">remove_args</span>(funcs: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> HashMap<span style="color:#f92672">&lt;</span>String, Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>, name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (_k, v) <span style="color:#66d9ef">in</span> funcs.iter_mut() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(pos) <span style="color:#f92672">=</span> v.iter().position(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> e <span style="color:#f92672">==</span> name) {
</span></span><span style="display:flex;"><span>            v.remove(pos);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sort_functions</span>(funcs: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> working <span style="color:#f92672">=</span> funcs.clone();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">!</span>working.is_empty() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> keys: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> working.keys().cloned().collect();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> found_something <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> k <span style="color:#66d9ef">in</span> keys {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> args <span style="color:#f92672">=</span> working.get(<span style="color:#f92672">&amp;</span>k).unwrap();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> args.is_empty() {
</span></span><span style="display:flex;"><span>                result.push(k.clone());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                remove_args(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> working, <span style="color:#f92672">&amp;</span>k);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                working.remove(<span style="color:#f92672">&amp;</span>k);
</span></span><span style="display:flex;"><span>                found_something <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// if we get here without breaking then we must have a loop or arguments that don&#39;t match functions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>found_something {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// TODO: real errors here please
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            println!(<span style="color:#e6db74">&#34;working left with: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, working);
</span></span><span style="display:flex;"><span>            panic!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;Could not find any functions that have no parameters left. There must be a loop or parameters that don&#39;t match any functions.&#34;</span>
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>First we need a modifiable copy of our hashmap of functions and their arguments, we need to remove things from this as we work so its nicer to take a clone of it here.</p>
<p>Then we get on to the actual algorithm its self. This looks a bit more complex due to rust and the borrow checker, but the principle remains the same. Look through our working map of functions, find one that doesn&rsquo;t have any arguments. This means it has no dependencies, so add it to the result list. Then go through the working map and remove any arguments with the name of the function we have. We also need to remove the function from the working map or we will end up with an infinite loop.</p>
<p>Then we start again, and we keep going until the working map is empty. If we ever manage to loop over all the entries in the working map and don&rsquo;t find an entry that has no arguments, it means we have a loop somewhere, or we have argument names that don&rsquo;t match a function we know of. Either way that&rsquo;s an error and we need to tell the user about it, or in our case panic and stop the program.</p>
<p>One thing to note about this implementation is it is not entirely stable, by design. If there are two functions that take the same arguments, we don&rsquo;t care what order they run in. <code>working.keys()</code> returns the keys in a random order. If two configs don&rsquo;t have a defined order it should not matter which order they run in. If there is accidentally a dependency then that is a bug and they should have an extra parameter to make the ordering defined.</p>
<h1 id="part-6-running-the-configure-functions">Part 6: Running the configure functions<a hidden class="anchor" aria-hidden="true" href="#part-6-running-the-configure-functions">#</a></h1>
<p>Now that we have the information about all the configure functions and know the order they need to be executed in, we can start running them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> sorted_functions <span style="color:#f92672">=</span> sort_functions(<span style="color:#f92672">&amp;</span>dependencies);
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, sorted_functions);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// execute the functions, keeping track of their results, looking up the arguments as needed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> results_map: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, Config<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> func_name <span style="color:#66d9ef">in</span> sorted_functions {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#e6db74">&#34;Executing </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>func_name);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> args <span style="color:#f92672">=</span> dependencies.get(<span style="color:#f92672">&amp;</span>func_name).unwrap();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> kwargs <span style="color:#f92672">=</span> create_kwargs(py, <span style="color:#f92672">&amp;</span>results_map, args)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> result: <span style="color:#a6e22e">Config</span> <span style="color:#f92672">=</span> functions
</span></span><span style="display:flex;"><span>                .get(<span style="color:#f92672">&amp;</span>func_name)
</span></span><span style="display:flex;"><span>                .unwrap()
</span></span><span style="display:flex;"><span>                .call((), Some(<span style="color:#f92672">&amp;</span>kwargs))<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                .extract()<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            results_map.insert(func_name.clone(), result);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;results: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, results_map);
</span></span></code></pre></div><p>The code here loops over the list of function names that comes out of the sort function. Builds a set of <code>kwargs</code> (Key word args in python land) which is a <code>PyDict</code> that gets expanded into named arguments. Calls the function with those kwargs and finally stores the result for later.</p>
<p>When we create the kwargs we have to build a <code>PyDict</code>, I also convert our <code>Config</code> objects into <code>ReadOnlyConfig</code> objects so that later configure functions can not mess with the results of earlier functions. This is a near clone of the original <code>Config</code> object but it doesn&rsquo;t have the constructor function or the <code>set_all</code> argument on the <code>pyclass</code> macro. There is also a function to create one from a <code>Config</code> object.</p>
<p>The <code>create_kwargs</code> is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_kwargs</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>    py: <span style="color:#a6e22e">Python</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    existing_results: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, Config<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    args: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#a6e22e">PyResult</span><span style="color:#f92672">&lt;</span>Bound<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;l</span>, PyDict<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> PyDict::new(py);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> arg <span style="color:#66d9ef">in</span> args {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> cr <span style="color:#f92672">=</span> existing_results.get(<span style="color:#f92672">&amp;</span>arg.to_string());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> cr.is_none() {
</span></span><span style="display:flex;"><span>            panic!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;Couldn&#39;t find existing result for </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">. This shouldn&#39;t be possible if the sort worked right&#34;</span>,
</span></span><span style="display:flex;"><span>                arg
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        result.set_item(arg, ReadOnlyConfig::from_config(cr.unwrap()))<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(result)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As usual the error handling can be massively improved here, but something has gone horribly wrong if we don&rsquo;t have a result for a function we need. The sort would have had to have broken somehow.</p>
<p>Now we have a fully working configuration system, if MVP level of implementation, rather than production code. Lets run it on our config and see what happens.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>emily@diamondslab:~/Projects/breezeblock$ cargo run
</span></span><span style="display:flex;"><span>    Finished <span style="color:#e6db74">`</span>dev<span style="color:#e6db74">`</span> profile <span style="color:#f92672">[</span>unoptimized + debuginfo<span style="color:#f92672">]</span> target<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> in 0.02s
</span></span><span style="display:flex;"><span>     Running <span style="color:#e6db74">`</span>target/debug/breezeblock<span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>func configA args: <span style="color:#f92672">[]</span>
</span></span><span style="display:flex;"><span>func configB args: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;configA&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>func configC args: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;configA&#34;</span>, <span style="color:#e6db74">&#34;configB&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>dependencies: 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;configC&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;configA&#34;</span>, <span style="color:#e6db74">&#34;configB&#34;</span><span style="color:#f92672">]</span>, <span style="color:#e6db74">&#34;configA&#34;</span>: <span style="color:#f92672">[]</span>, <span style="color:#e6db74">&#34;configB&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;configA&#34;</span><span style="color:#f92672">]}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#e6db74">&#34;configA&#34;</span>, <span style="color:#e6db74">&#34;configB&#34;</span>, <span style="color:#e6db74">&#34;configC&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Executing configA
</span></span><span style="display:flex;"><span>Executing configB
</span></span><span style="display:flex;"><span>Executing configC
</span></span><span style="display:flex;"><span>results: <span style="color:#f92672">{</span><span style="color:#e6db74">&#34;configB&#34;</span>: Config <span style="color:#f92672">{</span> config_class: <span style="color:#e6db74">&#34;&#34;</span>, repository: <span style="color:#e6db74">&#34;&#34;</span>, name: <span style="color:#e6db74">&#34;blah_with_something_extra&#34;</span>, features: <span style="color:#f92672">[]</span>, parameters: <span style="color:#f92672">{}</span> <span style="color:#f92672">}</span>, <span style="color:#e6db74">&#34;configC&#34;</span>: Config <span style="color:#f92672">{</span> config_class: <span style="color:#e6db74">&#34;&#34;</span>, repository: <span style="color:#e6db74">&#34;&#34;</span>, name: <span style="color:#e6db74">&#34;blah_with_something_extra_and_even_more_blah&#34;</span>, features: <span style="color:#f92672">[]</span>, parameters: <span style="color:#f92672">{}</span> <span style="color:#f92672">}</span>, <span style="color:#e6db74">&#34;configA&#34;</span>: Config <span style="color:#f92672">{</span> config_class: <span style="color:#e6db74">&#34;&#34;</span>, repository: <span style="color:#e6db74">&#34;&#34;</span>, name: <span style="color:#e6db74">&#34;blah&#34;</span>, features: <span style="color:#f92672">[]</span>, parameters: <span style="color:#f92672">{}</span> <span style="color:#f92672">}}</span>
</span></span></code></pre></div><p>In the results section at the end we can see it has done what we wanted.</p>
<p>There are many improvements that could be made here, but the basic principle works just fine. Now we can go and do something with our config objects.</p>
<p>I&rsquo;ve pushed the full code up to <a href="https://codeberg.org/emily_s/breezeblock">codeberg</a> so if you want to play around with it feel free. If you find this interesting or want to use it in something I&rsquo;d love to hear from you, drop me a message on mastodon @emily_<a href="mailto:s@mastodon.me.uk">s@mastodon.me.uk</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://parsecsreach.org/tags/rust/">rust</a></li>
      <li><a href="https://parsecsreach.org/tags/python/">python</a></li>
      <li><a href="https://parsecsreach.org/tags/pyo3/">pyo3</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://parsecsreach.org/post/pyo3_config_part_1/">
    <span class="title">Next »</span>
    <br>
    <span>Using python to configure rust Part 1</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>All rights reserved - 2022</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>

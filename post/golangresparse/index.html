<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Golang Resparse | Parsecs Reach</title>
<meta name="keywords" content="go, golang, resparse">
<meta name="description" content="A little while ago I found my self needing to be able to parse screen resolutions when generating some images in a golang program. I created a library to do this and had a bit of fun optimising it. The result is open source on github. It is a very simple library with a single function but I thought it might be interesting to walk you through the process.
What we need to build is a function that takes a string like &ldquo;1080p&rdquo;, &ldquo;800x600&rdquo;, or &ldquo;4K&rdquo; and returns a width and height value.">
<meta name="author" content="Emily Selwood">
<link rel="canonical" href="https://parsecsreach.org/post/golangresparse/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://parsecsreach.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://parsecsreach.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://parsecsreach.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://parsecsreach.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://parsecsreach.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Golang Resparse" />
<meta property="og:description" content="A little while ago I found my self needing to be able to parse screen resolutions when generating some images in a golang program. I created a library to do this and had a bit of fun optimising it. The result is open source on github. It is a very simple library with a single function but I thought it might be interesting to walk you through the process.
What we need to build is a function that takes a string like &ldquo;1080p&rdquo;, &ldquo;800x600&rdquo;, or &ldquo;4K&rdquo; and returns a width and height value." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://parsecsreach.org/post/golangresparse/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-12-08T13:28:33+00:00" />
<meta property="article:modified_time" content="2018-12-08T13:28:33+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang Resparse"/>
<meta name="twitter:description" content="A little while ago I found my self needing to be able to parse screen resolutions when generating some images in a golang program. I created a library to do this and had a bit of fun optimising it. The result is open source on github. It is a very simple library with a single function but I thought it might be interesting to walk you through the process.
What we need to build is a function that takes a string like &ldquo;1080p&rdquo;, &ldquo;800x600&rdquo;, or &ldquo;4K&rdquo; and returns a width and height value."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://parsecsreach.org/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Golang Resparse",
      "item": "https://parsecsreach.org/post/golangresparse/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang Resparse",
  "name": "Golang Resparse",
  "description": "A little while ago I found my self needing to be able to parse screen resolutions when generating some images in a golang program. I created a library to do this and had a bit of fun optimising it. The result is open source on github. It is a very simple library with a single function but I thought it might be interesting to walk you through the process.\nWhat we need to build is a function that takes a string like \u0026ldquo;1080p\u0026rdquo;, \u0026ldquo;800x600\u0026rdquo;, or \u0026ldquo;4K\u0026rdquo; and returns a width and height value.",
  "keywords": [
    "go", "golang", "resparse"
  ],
  "articleBody": "A little while ago I found my self needing to be able to parse screen resolutions when generating some images in a golang program. I created a library to do this and had a bit of fun optimising it. The result is open source on github. It is a very simple library with a single function but I thought it might be interesting to walk you through the process.\nWhat we need to build is a function that takes a string like “1080p”, “800x600”, or “4K” and returns a width and height value. There should also be an error in the return type just in case we can’t parse the string.\nThis is going to be a very basic walkthrough of what I did so if you know a bit of go you probably can skip this one. Or skip to the sections on benchmarking and optimization.\nAssumptions You have a working golang 1.11+ installation on your machine.\nSetting up the project Open a terminal and browse to where you want to put the project. It does not have to be in your GOPATH any more. Create a directory and move into it.\nmkdir resparse cd resparse Set up the module with the go mod tool. It may complain you need to set a GOPATH if you don’t already have it set. As we are not inside our GOPATH we need to tell the module tool what the package path of our project is.\ngo mod init github.com/wselwood/resparse Building the code Now open up your favourte editor. (I use VS code with the excellent go plugin) and create a new file called resolution.go and create a function place holder for our parsing function.\npackage resparse func ParseResolution(in string) (int, int, error) { return 0, 0, nil } This function takes in the string and returns x, y, and error values that match up to the input string. Now that we have created this place holder we can create a test harness so that we know if the code we are writing is working. Create a new file called resolution_test.go. We will use a table driven test for this as it will make it easier for us to add new cases as we think of them.\npackage resparse import ( \"testing\" ) type testCase struct { input string x int y int err string } var cases = []testCase{} func TestBasicParse(t *testing.T) { for _, test := range cases { t.Run(test.input, func(t *testing.T) { x, y, err := ParseResolution(test.input) if (err != nil \u0026\u0026 test.err == \"\") || (err != nil \u0026\u0026 err.Error() != test.err) { t.Errorf(\"wrong error from parsing \\\"%v\\\" got \\\"%v\\\" expected \\\"%v\\\"\", test.input, err.Error(), test.err) } else if x != test.x || y != test.y { t.Errorf(\"got wrong result from parsing \\\"%v\\\" got (%v,%v) expected (%v,%v)\", test.input, x, y, test.x, test.y) } }) } } This is a reasonably long block of code so lets go over it. First we define the package, and import the built in testing package. Next we define a testCase struct that holds an input string and the expected output values. The next line defines an empty list of test cases. Finally we get to the test function its self. Inside we loop over the testcases.\nThe next bit runs each test as a sub test. This is a useful ability of the go test library as it gives the option to run each of the sub tests in parallel which can speed up the test time significantly.\nWe can add a couple of basic test cases and then get on with the function its self.\n{\"\", -1, -1, \"could not parse \\\"\\\" as a resolution\"}, {\" SVGA\", 800, 600, \"\"}, {\"WSVGA\", 1024, 600, \"\"}, {\"800x600\", 800, 600, \"\"}, {\"1600|1200\", 1600, 1200, \"\"}, {\"dgsfgd,4000\", -1, -1, \"could not parse \\\"dgsfgd,4000\\\" as a resolution\"}, This will give us some where to work. If you run this test now it will print a lot of failures.\nwselwood@DESKTOP:/git/resparse$ go test . --- FAIL: TestBasicParse (0.00s) --- FAIL: TestBasicParse/#00 (0.00s) resolution_test.go:31: got wrong result from parsing \"\" got (0,0) expected (-1,-1) --- FAIL: TestBasicParse/_SVGA (0.00s) resolution_test.go:31: got wrong result from parsing \" SVGA\" got (0,0) expected (800,600) --- FAIL: TestBasicParse/WSVGA (0.00s) resolution_test.go:31: got wrong result from parsing \"WSVGA\" got (0,0) expected (1024,600) --- FAIL: TestBasicParse/800x600 (0.00s) resolution_test.go:31: got wrong result from parsing \"800x600\" got (0,0) expected (800,600) --- FAIL: TestBasicParse/1600|1200 (0.00s) resolution_test.go:31: got wrong result from parsing \"1600|1200\" got (0,0) expected (1600,1200) --- FAIL: TestBasicParse/dgsfgd,4000 (0.00s) resolution_test.go:31: got wrong result from parsing \"dgsfgd,4000\" got (0,0) expected (-1,-1) FAIL FAIL github.com/wselwood/resparse 0.008s So lets go and start building our parsing function. We can start with the first test and check for empty or blank strings being passed in. We can trim the string and then check if it is empty. Returning an error if needed.\nwork := strings.TrimSpace(in) if work == \"\" { return -1, -1, fmt.Errorf(\"could not parse \\\"\\\" as a resolution\") } Next we can create the look up table needed to handle named resolutions. Converting things like “SVGA” to 800,600,nil. Outside the function create a new struct type to hold the x, y pairs.\ntype res struct { x int y int } var known = map[string]res{ \"1080P\": {1920, 1080}, \"WSVGA\": {1024, 600}, \"SVGA\": {800, 600}, } We can add more entires later, for now lets just keep those entires. Now we can look up our trimmed input string in the known map. We can use the second return value from the map lookup to know if we found a valid response. We will call strings.ToUpper() to make sure all the input values are easier to match against our known values.\nresult, ok := known[strings.ToUpper(trimmed)] if ok { return result.x, result.y, nil } If we don’t get a response from that we should try and split the string and then try and convert to a pair of numbers. Replace the old zero return with the following:\nsplitStart := strings.IndexAny(trimmed, \"Xx| ,*\") splitEnd := strings.LastIndexAny(trimmed, \"Xx| ,*\") width := trimmed[:splitStart] height := trimmed[splitEnd+1:] x, err := strconv.Atoi(width) if err != nil { return -1, -1, fmt.Errorf(\"could not parse \\\"%v\\\" as a resolution\", in) } y, err := strconv.Atoi(height) if err != nil { return -1, -1, fmt.Errorf(\"could not parse \\\"%v\\\" as a resolution\", in) } return x, y, nil Now if we run the test cases we should get a clear run. At this point we could call it done. But I’m not going to, first we are going to create a benchmark and then we are going to see if we can tune this function a bit.\nBenchmarking Before we can start doing any optimization we need to see how long this function is taking. Thankfully go has a reasonable benchmarking tool built into the testing library. If we hop back to our test file we can add a benchmark that uses the same test data as inputs.\nfunc BenchmarkParseResolution(b *testing.B) { for n := 0; n \u003c b.N; n++ { ParseResolution(cases[rand.Intn(len(cases))].input) } } The difference from a test is the use of the B object in testing and the function having to start with Benchmark. The B object has a value N which is the number of times to run the test. So we put that in a for loop for that many times. Then in each loop we pick a random entry from the cases list and run the ParseResolution function.\nGo will then take care of the rest for us. If we run this we should see something like the following:\nRunning tool: C:\\\\Go\\\\bin\\\\go.exe test -benchmem -run=^$ github.com/wselwood/resparse2 -bench ^BenchmarkParseResolution$ goos: windows goarch: amd64 pkg: github.com/wselwood/resparse2 BenchmarkParseResolution-4 10000000\t174 ns/op\t39 B/op\t1 allocs/op PASS ok github.com/wselwood/resparse2\t2.068s Success: Benchmarks passed. This tells us it ran with an b.N value of ten million and it took on average 174 NanoSeconds for each loop, which allocated 39 Bytes in one allocation. This is pretty good and for something like a command line tool where this is only called once at start up it is well within reasonable bounds. But lets not be reasonable, lets see what we can do here.\nFirst thing to do is see what it is actually doing for those 174 Nanoseconds. So we are going to run the benchmark with the cpu profile enabled. I use the shell built into vs code for this. There is something about the Windows Subsystem for Linux (WSL) that does not play nice with the profile tools in go. It will run but you will have a completely blank profile file at the end.\nPS C:\\git\\resparse2\u003e go test \"-cpuprofile=profile.pprof\" -bench . goos: windows goarch: amd64 pkg: github.com/wselwood/resparse2 BenchmarkParseResolution-4 10000000 177 ns/op PASS ok github.com/wselwood/resparse2 2.136s You should now find a profile.pprof file in the directory. To open this up we can use the go tool pprof command. This can be accessed from the command line but it has an excellent web ui that provides some great visualizations. To enable the web ui you need to tell it an http port to open up. If you have used the built in http tools at all the format of this string should look pretty familiar.\nPS C:\\\\git\\\\resparse2\u003e go tool pprof -http=:8000 .\\\\profile.pprof When you run this a web browser window should pop up with something like this:\nThis is basically a call graph of your benchmark with the calls that took more cpu time with larger and more defined arrows. The two unlinked trees off to one side are the test harness running in the background to keep track of things. Generally each go routine will end up with its own tree. You should be able to see that we spend most of our time creating errors, or in the string functions. Almost no time is spent in the map lookup or the number parsing.\nOptimization Given our ideal input we are going to end up looping over the string at least twice. At best once to do the separator finding at worst twice, and once for the ToUpper call. The call to Trim may or may not require any iteration of the string depending on if there are spaces. In the worst case where it is a completely blank string it will iterate the entire thing.\nSo we can avoid all of those if we make a single pass over the string and find, the start (after all the white space), the end (last character before all the white space), the start of the separator and the end of the separator. While we are at it we could also check if we need to upper case the string for the map look up. This should be a fairly simple loop with a bit of a state machine.\nFor a first pass we will just replace the trim and IndexOfAny functions with a single loop. The function becomes something like this:\nfunc ParseResolution(in string) (int, int, error) { start := -1 end := -1 sepStart := -1 sepEnd := -1 for i, c := range in { if !unicode.IsSpace(c) { if start == -1 { start = i } end = i } if c == 'X' || c == 'x' || c == ',' || c == ' ' || c == '|' || c == '*' { if sepStart == -1 { if start != -1 { sepStart = i } } else { if sepEnd == -1 || sepEnd == i-1 { sepEnd = i } } } } if start == -1 || end == -1 { return -1, -1, fmt.Errorf(\"could not parse \\\"%v\\\" as a resolution\", in) } result, ok := known[strings.ToUpper(in[start:end+1])] if ok { return result.x, result.y, nil } // if it is not in our lookup table then try and split the string if sepStart == -1 || sepStart == start || sepEnd == end { return -1, -1, fmt.Errorf(\"could not parse \\\"%v\\\" as a resolution\", in) } if sepStart != -1 \u0026\u0026 sepEnd == -1 { sepEnd = sepStart } width := in[start:sepStart] height := in[sepEnd+1 : end+1] x, err := strconv.Atoi(width) if err != nil { return -1, -1, fmt.Errorf(\"could not parse \\\"%v\\\" as a resolution\", in) } y, err := strconv.Atoi(height) if err != nil { return -1, -1, fmt.Errorf(\"could not parse \\\"%v\\\" as a resolution\", in) } return x, y, nil } If we run the benchmark now we see:\nRunning tool: C:\\\\Go\\\\bin\\\\go.exe test -benchmem -run=^$ github.com/wselwood/resparse2 -bench ^BenchmarkParseResolution$ goos: windows goarch: amd64 pkg: github.com/wselwood/resparse2 BenchmarkParseResolution-4 10000000\t164 ns/op\t39 B/op\t1 allocs/op PASS ok github.com/wselwood/resparse2\t1.955s Success: Benchmarks passed. You can see we have shaved 10 nano seconds per op off. We haven’t managed to stop it allocating. It is the ToUpper function that needs that. Now if we look at the graph again:\nWe can see that the ToUpper call is more defined now and the calls to Trim and IndexOfAny have gone away. Also the random number generation in our benchmark code has got more pronounced. The last change is to make it check in the loop if the character needs to be upper cased later. At this point we are where I stopped so I’m going to use my current code.\nThis gives a benchmark output:\nRunning tool: C:\\\\Go\\\\bin\\\\go.exe test -benchmem -run=^$ github.com/wselwood/resparse -bench ^BenchmarkParseResolution$ goos: windows goarch: amd64 pkg: github.com/wselwood/resparse BenchmarkParseResolution-4 10000000\t142 ns/op\t15 B/op\t0 allocs/op PASS ok github.com/wselwood/resparse\t1.744s Success: Benchmarks passed. We have shaved another 20 nano seconds off, and managed to half the average allocation size. Note this is averages over the 10 million operations here so going from 1 to 0 average allocations is probably only just under half of them. Now if we look at the profile we can see our map lookup has become a large amount of the time and the ToUpper is now smaller.\nConclusion While it was probably not really worth going to this level of optimization with this chunk of code, it was interesting and hopefully provided a good introduction to the profile and benchmark tools provided with Go. There is a lot more power in the profile tools that I have not explored here. I recommend Rakyll’s excellent blog for further reading. I hope you gained something from this. If you did, or have any questions, please let me know on twitter.\n",
  "wordCount" : "2386",
  "inLanguage": "en",
  "datePublished": "2018-12-08T13:28:33Z",
  "dateModified": "2018-12-08T13:28:33Z",
  "author":{
    "@type": "Person",
    "name": "Emily Selwood"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://parsecsreach.org/post/golangresparse/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Parsecs Reach",
    "logo": {
      "@type": "ImageObject",
      "url": "https://parsecsreach.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://parsecsreach.org" accesskey="h" title="Parsecs Reach (Alt + H)">Parsecs Reach</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a rel="" href="https://parsecsreach.org/orbviewer"  target="_blank" title="Orb Viewer">
                    <span>Orb Viewer</span>
                    
                </a>
            </li>
            <li>
                <a rel="me" href="https://tech.lgbt/@emily_s"  target="_blank" title="@emily_s@tech.lgbt">
                    <span>@emily_s@tech.lgbt</span>
                    
                </a>
            </li>
            <li>
                <a rel="" href="https://github.com/emilyselwood"  target="_blank" title="GitHub">
                    <span>GitHub</span>
                    
                </a>
            </li>
            <li>
                <a rel="" href="https://parsecsreach.org/about"  target="_self" title="About me">
                    <span>About me</span>
                    
                </a>
            </li>
            <li>
                <a rel="" href="https://parsecsreach.org/"  target="_self" title="Home">
                    <span>Home</span>
                    
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Golang Resparse
    </h1>
    <div class="post-meta"><span title='2018-12-08 13:28:33 +0000 UTC'>2018 December 8</span>&nbsp;·&nbsp;Emily Selwood

</div>
  </header> 
  <div class="post-content"><p>A little while ago I found my self needing to be able to parse screen resolutions when generating some images in a golang program. I created a library to do this and had a bit of fun optimising it. The result is open source on <a href="https://github.com/wselwood/resparse">github</a>. It is a very simple library with a single function but I thought it might be interesting to walk you through the process.</p>
<p>What we need to build is a function that takes a string like &ldquo;1080p&rdquo;, &ldquo;800x600&rdquo;, or &ldquo;4K&rdquo; and returns a width and height value. There should also be an error in the return type just in case we can&rsquo;t parse the string.</p>
<p>This is going to be a very basic walkthrough of what I did so if you know a bit of go you probably can skip this one. Or skip to the sections on benchmarking and optimization.</p>
<h1 id="assumptions">Assumptions<a hidden class="anchor" aria-hidden="true" href="#assumptions">#</a></h1>
<p>You have a working <a href="https://golang.org/">golang</a> 1.11+ installation on your machine.</p>
<h1 id="setting-up-the-project">Setting up the project<a hidden class="anchor" aria-hidden="true" href="#setting-up-the-project">#</a></h1>
<p>Open a terminal and browse to where you want to put the project. It does not have to be in your GOPATH any more. Create a directory and move into it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir resparse
</span></span><span style="display:flex;"><span>cd resparse
</span></span></code></pre></div><p>Set up the module with the <code>go mod</code> tool. It may complain you need to set a GOPATH if you don&rsquo;t already have it set. As we are not inside our GOPATH we need to tell the module tool what the package path of our project is.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>go mod init github.com/wselwood/resparse
</span></span></code></pre></div><h1 id="building-the-code">Building the code<a hidden class="anchor" aria-hidden="true" href="#building-the-code">#</a></h1>
<p>Now open up your favourte editor. (I use VS code with the excellent go plugin) and create a new file called <code>resolution.go</code> and create a function place holder for our parsing function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">resparse</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ParseResolution</span>(<span style="color:#a6e22e">in</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function takes in the string and returns x, y, and error values that match up to the input string. Now that we have created this place holder we can create a test harness so that we know if the code we are writing is working. Create a new file called <code>resolution_test.go</code>. We will use a table driven test for this as it will make it easier for us to add new cases as we think of them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">resparse</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">testCase</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">input</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span>     <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">y</span>     <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cases</span> = []<span style="color:#a6e22e">testCase</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestBasicParse</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">test</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">cases</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">input</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ParseResolution</span>(<span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">input</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#f92672">||</span> (<span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">err</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;wrong error from parsing \&#34;%v\&#34; got \&#34;%v\&#34; expected \&#34;%v\&#34;&#34;</span>, <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">input</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">y</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;got wrong result from parsing \&#34;%v\&#34; got (%v,%v) expected (%v,%v)&#34;</span>, <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">input</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">test</span>.<span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a reasonably long block of code so lets go over it. First we define the package, and import the built in testing package. Next we define a <code>testCase</code> struct that holds an input string and the expected output values. The next line defines an empty list of test cases. Finally we get to the test function its self. Inside we loop over the testcases.</p>
<p>The next bit runs each test as a sub test. This is a useful ability of the go test library as it gives the option to run each of the sub tests in parallel which can speed up the test time significantly.</p>
<p>We can add a couple of basic test cases and then get on with the function its self.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	{<span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;could not parse \&#34;\&#34; as a resolution&#34;</span>},
</span></span><span style="display:flex;"><span>	{<span style="color:#e6db74">&#34; SVGA&#34;</span>, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>, <span style="color:#e6db74">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>	{<span style="color:#e6db74">&#34;WSVGA&#34;</span>, <span style="color:#ae81ff">1024</span>, <span style="color:#ae81ff">600</span>, <span style="color:#e6db74">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>	{<span style="color:#e6db74">&#34;800x600&#34;</span>, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>, <span style="color:#e6db74">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>	{<span style="color:#e6db74">&#34;1600|1200&#34;</span>, <span style="color:#ae81ff">1600</span>, <span style="color:#ae81ff">1200</span>, <span style="color:#e6db74">&#34;&#34;</span>},
</span></span><span style="display:flex;"><span>	{<span style="color:#e6db74">&#34;dgsfgd,4000&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;could not parse \&#34;dgsfgd,4000\&#34; as a resolution&#34;</span>},
</span></span></code></pre></div><p>This will give us some where to work. If you run this test now it will print a lot of failures.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wselwood@DESKTOP:/git/resparse$ go test .
</span></span><span style="display:flex;"><span>--- FAIL: TestBasicParse <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    --- FAIL: TestBasicParse/#00 <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        resolution_test.go:31: got wrong result from parsing <span style="color:#e6db74">&#34;&#34;</span> got <span style="color:#f92672">(</span>0,0<span style="color:#f92672">)</span> expected <span style="color:#f92672">(</span>-1,-1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    --- FAIL: TestBasicParse/_SVGA <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        resolution_test.go:31: got wrong result from parsing <span style="color:#e6db74">&#34; SVGA&#34;</span> got <span style="color:#f92672">(</span>0,0<span style="color:#f92672">)</span> expected <span style="color:#f92672">(</span>800,600<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    --- FAIL: TestBasicParse/WSVGA <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        resolution_test.go:31: got wrong result from parsing <span style="color:#e6db74">&#34;WSVGA&#34;</span> got <span style="color:#f92672">(</span>0,0<span style="color:#f92672">)</span> expected <span style="color:#f92672">(</span>1024,600<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    --- FAIL: TestBasicParse/800x600 <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        resolution_test.go:31: got wrong result from parsing <span style="color:#e6db74">&#34;800x600&#34;</span> got <span style="color:#f92672">(</span>0,0<span style="color:#f92672">)</span> expected <span style="color:#f92672">(</span>800,600<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    --- FAIL: TestBasicParse/1600|<span style="color:#ae81ff">1200</span> <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        resolution_test.go:31: got wrong result from parsing <span style="color:#e6db74">&#34;1600|1200&#34;</span> got <span style="color:#f92672">(</span>0,0<span style="color:#f92672">)</span> expected <span style="color:#f92672">(</span>1600,1200<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    --- FAIL: TestBasicParse/dgsfgd,4000 <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        resolution_test.go:31: got wrong result from parsing <span style="color:#e6db74">&#34;dgsfgd,4000&#34;</span> got <span style="color:#f92672">(</span>0,0<span style="color:#f92672">)</span> expected <span style="color:#f92672">(</span>-1,-1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>FAIL
</span></span><span style="display:flex;"><span>FAIL    github.com/wselwood/resparse   0.008s
</span></span></code></pre></div><p>So lets go and start building our parsing function. We can start with the first test and check for empty or blank strings being passed in. We can trim the string and then check if it is empty. Returning an error if needed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">work</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">TrimSpace</span>(<span style="color:#a6e22e">in</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">work</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;could not parse \&#34;\&#34; as a resolution&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Next we can create the look up table needed to handle named resolutions. Converting things like &ldquo;SVGA&rdquo; to 800,600,nil. Outside the function create a new struct type to hold the x, y pairs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">res</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">known</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">res</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;1080P&#34;</span>: {<span style="color:#ae81ff">1920</span>, <span style="color:#ae81ff">1080</span>},
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;WSVGA&#34;</span>: {<span style="color:#ae81ff">1024</span>, <span style="color:#ae81ff">600</span>},
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;SVGA&#34;</span>:  {<span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>},
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can add more entires later, for now lets just keep those entires. Now we can look up our trimmed input string in the <code>known</code> map. We can use the second return value from the map lookup to know if we found a valid response. We will call <code>strings.ToUpper()</code> to make sure all the input values are easier to match against our known values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">known</span>[<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToUpper</span>(<span style="color:#a6e22e">trimmed</span>)]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">y</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>If we don&rsquo;t get a response from that we should try and split the string and then try and convert to a pair of numbers. Replace the old zero return with the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">splitStart</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">IndexAny</span>(<span style="color:#a6e22e">trimmed</span>, <span style="color:#e6db74">&#34;Xx| ,*&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">splitEnd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">LastIndexAny</span>(<span style="color:#a6e22e">trimmed</span>, <span style="color:#e6db74">&#34;Xx| ,*&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">width</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">trimmed</span>[:<span style="color:#a6e22e">splitStart</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">height</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">trimmed</span>[<span style="color:#a6e22e">splitEnd</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">width</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;could not parse \&#34;%v\&#34; as a resolution&#34;</span>, <span style="color:#a6e22e">in</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">height</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;could not parse \&#34;%v\&#34; as a resolution&#34;</span>, <span style="color:#a6e22e">in</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#66d9ef">nil</span>
</span></span></code></pre></div><p>Now if we run the test cases we should get a clear run. At this point we could call it done. But I&rsquo;m not going to, first we are going to create a benchmark and then we are going to see if we can tune this function a bit.</p>
<h1 id="benchmarking">Benchmarking<a hidden class="anchor" aria-hidden="true" href="#benchmarking">#</a></h1>
<p>Before we can start doing any optimization we need to see how long this function is taking. Thankfully go has a reasonable benchmarking tool built into the testing library. If we hop back to our test file we can add a benchmark that uses the same test data as inputs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkParseResolution</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">n</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ParseResolution</span>(<span style="color:#a6e22e">cases</span>[<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Intn</span>(len(<span style="color:#a6e22e">cases</span>))].<span style="color:#a6e22e">input</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The difference from a test is the use of the <code>B</code> object in <code>testing</code> and the function having to start with <code>Benchmark</code>. The <code>B</code> object has a value <code>N</code> which is the number of times to run the test. So we put that in a for loop for that many times. Then in each loop we pick a random entry from the <code>cases</code> list and run the <code>ParseResolution</code> function.</p>
<p>Go will then take care of the rest for us. If we run this we should see something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Running tool: C:<span style="color:#ae81ff">\\</span>Go<span style="color:#ae81ff">\\</span>bin<span style="color:#ae81ff">\\</span>go.exe test -benchmem -run<span style="color:#f92672">=</span>^$ github.com/wselwood/resparse2 -bench ^BenchmarkParseResolution$
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>goos: windows
</span></span><span style="display:flex;"><span>goarch: amd64
</span></span><span style="display:flex;"><span>pkg: github.com/wselwood/resparse2
</span></span><span style="display:flex;"><span>BenchmarkParseResolution-4   	10000000	       <span style="color:#ae81ff">174</span> ns/op	      <span style="color:#ae81ff">39</span> B/op	       <span style="color:#ae81ff">1</span> allocs/op
</span></span><span style="display:flex;"><span>PASS
</span></span><span style="display:flex;"><span>ok  	github.com/wselwood/resparse2	2.068s
</span></span><span style="display:flex;"><span>Success: Benchmarks passed.
</span></span></code></pre></div><p>This tells us it ran with an <code>b.N</code> value of ten million and it took on average 174 NanoSeconds for each loop, which allocated 39 Bytes in one allocation. This is pretty good and for something like a command line tool where this is only called once at start up it is well within reasonable bounds. But lets not be reasonable, lets see what we can do here.</p>
<p>First thing to do is see what it is actually doing for those 174 Nanoseconds. So we are going to run the benchmark with the cpu profile enabled. I use the shell built into vs code for this. There is something about the Windows Subsystem for Linux (WSL) that does not play nice with the profile tools in go. It will run but you will have a completely blank profile file at the end.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PS C:<span style="color:#ae81ff">\g</span>it<span style="color:#ae81ff">\r</span>esparse2&gt; go test <span style="color:#e6db74">&#34;-cpuprofile=profile.pprof&#34;</span> -bench .
</span></span><span style="display:flex;"><span>goos: windows
</span></span><span style="display:flex;"><span>goarch: amd64
</span></span><span style="display:flex;"><span>pkg: github.com/wselwood/resparse2
</span></span><span style="display:flex;"><span>BenchmarkParseResolution-4      <span style="color:#ae81ff">10000000</span>               <span style="color:#ae81ff">177</span> ns/op
</span></span><span style="display:flex;"><span>PASS
</span></span><span style="display:flex;"><span>ok      github.com/wselwood/resparse2   2.136s
</span></span></code></pre></div><p>You should now find a profile.pprof file in the directory. To open this up we can use the <code>go tool pprof</code> command. This can be accessed from the command line but it has an excellent web ui that provides some great visualizations. To enable the web ui you need to tell it an http port to open up. If you have used the built in http tools at all the format of this string should look pretty familiar.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PS C:<span style="color:#ae81ff">\\</span>git<span style="color:#ae81ff">\\</span>resparse2&gt; go tool pprof -http<span style="color:#f92672">=</span>:8000 .<span style="color:#ae81ff">\\</span>profile.pprof
</span></span></code></pre></div><p>When you run this a web browser window should pop up with something like this:</p>
<p><img loading="lazy" src="/img/golang/resparse-pprof1.PNG" alt="pprof graph view"  />
</p>
<p>This is basically a call graph of your benchmark with the calls that took more cpu time with larger and more defined arrows. The two unlinked trees off to one side are the test harness running in the background to keep track of things. Generally each go routine will end up with its own tree. You should be able to see that we spend most of our time creating errors, or in the string functions. Almost no time is spent in the map lookup or the number parsing.</p>
<h1 id="optimization">Optimization<a hidden class="anchor" aria-hidden="true" href="#optimization">#</a></h1>
<p>Given our ideal input we are going to end up looping over the string at least twice. At best once to do the separator finding at worst twice, and once for the <code>ToUpper</code> call. The call to Trim may or may not require any iteration of the string depending on if there are spaces. In the worst case where it is a completely blank string it will iterate the entire thing.</p>
<p>So we can avoid all of those if we make a single pass over the string and find, the start (after all the white space), the end (last character before all the white space), the start of the separator and the end of the separator. While we are at it we could also check if we need to upper case the string for the map look up. This should be a fairly simple loop with a bit of a state machine.</p>
<p>For a first pass we will just replace the <code>trim</code> and <code>IndexOfAny</code> functions with a single loop. The function becomes something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ParseResolution</span>(<span style="color:#a6e22e">in</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sepStart</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sepEnd</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">in</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">unicode</span>.<span style="color:#a6e22e">IsSpace</span>(<span style="color:#a6e22e">c</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">start</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">end</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;X&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;x&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;|&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sepStart</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">sepStart</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sepEnd</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">sepEnd</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">sepEnd</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">end</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;could not parse \&#34;%v\&#34; as a resolution&#34;</span>, <span style="color:#a6e22e">in</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">known</span>[<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToUpper</span>(<span style="color:#a6e22e">in</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">end</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">y</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// if it is not in our lookup table then try and split the string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sepStart</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">sepStart</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">sepEnd</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">end</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;could not parse \&#34;%v\&#34; as a resolution&#34;</span>, <span style="color:#a6e22e">in</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sepStart</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sepEnd</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sepEnd</span> = <span style="color:#a6e22e">sepStart</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">width</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">in</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">sepStart</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">height</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">in</span>[<span style="color:#a6e22e">sepEnd</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> : <span style="color:#a6e22e">end</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">width</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;could not parse \&#34;%v\&#34; as a resolution&#34;</span>, <span style="color:#a6e22e">in</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">height</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;could not parse \&#34;%v\&#34; as a resolution&#34;</span>, <span style="color:#a6e22e">in</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we run the benchmark now we see:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Running tool: C:<span style="color:#ae81ff">\\</span>Go<span style="color:#ae81ff">\\</span>bin<span style="color:#ae81ff">\\</span>go.exe test -benchmem -run<span style="color:#f92672">=</span>^$ github.com/wselwood/resparse2 -bench ^BenchmarkParseResolution$
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>goos: windows
</span></span><span style="display:flex;"><span>goarch: amd64
</span></span><span style="display:flex;"><span>pkg: github.com/wselwood/resparse2
</span></span><span style="display:flex;"><span>BenchmarkParseResolution-4   	10000000	       <span style="color:#ae81ff">164</span> ns/op	      <span style="color:#ae81ff">39</span> B/op	       <span style="color:#ae81ff">1</span> allocs/op
</span></span><span style="display:flex;"><span>PASS
</span></span><span style="display:flex;"><span>ok  	github.com/wselwood/resparse2	1.955s
</span></span><span style="display:flex;"><span>Success: Benchmarks passed.
</span></span></code></pre></div><p>You can see we have shaved 10 nano seconds per op off. We haven&rsquo;t managed to stop it allocating. It is the ToUpper function that needs that. Now if we look at the graph again:</p>
<p><img loading="lazy" src="/img/golang/resparse-pprof2.PNG" alt="pprof graph view"  />
</p>
<p>We can see that the <code>ToUpper</code> call is more defined now and the calls to <code>Trim</code> and <code>IndexOfAny</code> have gone away. Also the random number generation in our benchmark code has got more pronounced. The last change is to make it check in the loop if the character needs to be upper cased later. At this point we are where I stopped so I&rsquo;m going to use my <a href="https://github.com/wselwood/resparse/blob/a42bf694a9fae8c78dfc28ad69d6d356ec843995/resolution.go">current code</a>.</p>
<p>This gives a benchmark output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Running tool: C:<span style="color:#ae81ff">\\</span>Go<span style="color:#ae81ff">\\</span>bin<span style="color:#ae81ff">\\</span>go.exe test -benchmem -run<span style="color:#f92672">=</span>^$ github.com/wselwood/resparse -bench ^BenchmarkParseResolution$
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>goos: windows
</span></span><span style="display:flex;"><span>goarch: amd64
</span></span><span style="display:flex;"><span>pkg: github.com/wselwood/resparse
</span></span><span style="display:flex;"><span>BenchmarkParseResolution-4   	10000000	       <span style="color:#ae81ff">142</span> ns/op	      <span style="color:#ae81ff">15</span> B/op	       <span style="color:#ae81ff">0</span> allocs/op
</span></span><span style="display:flex;"><span>PASS
</span></span><span style="display:flex;"><span>ok  	github.com/wselwood/resparse	1.744s
</span></span><span style="display:flex;"><span>Success: Benchmarks passed.
</span></span></code></pre></div><p>We have shaved another 20 nano seconds off, and managed to half the average allocation size. Note this is averages over the 10 million operations here so going from 1 to 0 average allocations is probably only just under half of them. Now if we look at the profile we can see our map lookup has become a large amount of the time and the ToUpper is now smaller.</p>
<p><img loading="lazy" src="/img/golang/resparse-pprof3.PNG" alt="pprof graph view"  />
</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>While it was probably not really worth going to this level of optimization with this chunk of code, it was interesting and hopefully provided a good introduction to the profile and benchmark tools provided with Go. There is a lot more power in the profile tools that I have not explored here. I recommend <a href="https://rakyll.org/pprof-ui/">Rakyll&rsquo;s excellent blog</a> for further reading. I hope you gained something from this. If you did, or have any questions, please let me know on twitter.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://parsecsreach.org/tags/go/">go</a></li>
      <li><a href="https://parsecsreach.org/tags/golang/">golang</a></li>
      <li><a href="https://parsecsreach.org/tags/resparse/">resparse</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://parsecsreach.org/post/its_me/">
    <span class="title">« Prev</span>
    <br>
    <span>Announcing a new me</span>
  </a>
  <a class="next" href="https://parsecsreach.org/post/wsl_dot_files/">
    <span class="title">Next »</span>
    <br>
    <span>Windows Subsystem for Linux Dot files</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>All rights reserved - 2022</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
